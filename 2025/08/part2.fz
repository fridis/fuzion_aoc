dec8 =>

  input := io.stdin.read_string.trim.split "\n"
             .map (.split "," .map (.parse_i64.val) .as_array) .as_array
  n := input.length
  m := envir.args.count < 2 ? 1000 : envir.args[1].parse_i32.val

  pairs := (0..n-1).flat_map (i -> (i+1..n-1).map (pair i))
                   .sort

  # get circuit id of junction box i
  #
  # cs[i] is >0 if i is identifying box, value is size of circuit,
  #          <0 if identifying box is at i+cs[i]
  circuit(cs, i) =>
    if cs[i]<0 then circuit cs i+cs[i]
               else i

  # pair of junction box i and j,  ordered by straight-line distance
  pair(i,j) : property.orderable is

    # straight-line distance between i and j
    dist := input[i].zip input[j] (-) .map **2 .sum

    # order
    public redef type.lteq(a,b pair.this) bool => a.dist <= b.dist

    # connect this pair for given circuit cs, return resulting circuit
    connect(cs) =>
      ab := (circuit cs i, circuit cs j)
      a := ab ||> min
      b := ab ||> max
      if a=b then cs
             else array n x->
                    if      x=a              then cs[a] + cs[b]
                    else if circuit cs x = b then a-x
                                             else cs[x]

  part1 =>
    join(c,cs) i32 =>
      if c = m then cs.sort.reverse.take 3 .product
               else join c+1 (pairs[c].connect cs)
    join 0 (array n _->1)

  part2 =>
    join(c,cs) =>
      p := pairs[c]
      cs0 := p.connect cs
      if cs0[0]=n then input[p.i][0]*input[p.j][0]
                  else join c+1 cs0
    join 0 (array n _->1)

  say "$part1:$part2"
