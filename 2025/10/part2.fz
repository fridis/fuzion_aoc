dec10 =>

  input := io.stdin.read_string.trim.split "\n"
             .filter !=""
             .map (.split " ") .map data .as_array
  data(s) is
    lights := s[0].substring 1 s[0].byte_length-1 .codepoints.foldf (i32,i32) (0,1) e,c->
                (e.0|(c="#"?e.1:0),2*e.1)
               .0
    buttons := (s.drop 1 .take s.count-2).map (.substring 1 .replace ")" "" .split "," .foldf 0 e,c->e|1<<c.parse_i32.val) .as_array
    joltage := s.last.val.substring 1 .replace "}" "" .split "," .map (.parse_i32.val) # .as_array

    try(l,n) =>
      l=lights || n!=0 && (buttons âˆƒ b->try l^b n-1)

    p2 =>
      # solution proposed by u/tenthmascot at
      # https://www.reddit.com/r/adventofcode/comments/1pk87hl/2025_day_10_part_2_bifurcate_your_way_to_victory/
      solve(j) : memoize => keep "$s/$j" _->
        if j âˆ€ =0 then 0
        else
          l := j.indexed.map ||>i,jo->jo%2<<i .fold1 (|)    # odd joltages
          (0..(2**(buttons.length)-1)).map m->              # for all button combinations
              pr := buttons.zip (m :: (/2)) b,mb->mb%2*b    # pressed buttons
              if l=pr.fold1 (^) then                        # resulting lights ok?
                j2 := j.indexed.map ||>i,jo->(jo - (pr.map b->(b>>i)%2 .sum))/2
                m.ones_count + 2 * solve j2
              else 1000000
            .min.val
      solve joltage

  part1 =>
    input.map d->((0..).drop_while n->(!d.try 0 n))[0]
         .sum

  part2 =>
    input.map (.p2)
         .sum

  say "$part1:$part2"
