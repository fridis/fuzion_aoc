dec10 =>

  input := io.stdin.read_string.trim.split "\n"
             .map (.split " ") .map data .as_array

  data(s) is
    lights := s[0].replace "[" ""
                  .replace "]" ""
                  .codepoints.foldf (0,1) e,c->(e.0|(c="#"?e.1:0),2*e.1)
                  .0
    buttons := (s.drop 1 .take s.count-2).map (.replace "(" ""
                                               .replace ")" ""
                                               .split ","
                                               .map c->1<<c.parse_i32.val
                                               .fold1 (|))
                                         .as_array
    joltage := s.last.val.replace "\{" ""
                         .replace "\}" ""
                         .split ","
                         .map (.parse_i32.val)

    try(l,n) =>
      l=lights || n!=0 && (buttons âˆƒ b->try l^b n-1)

    p2 =>
      # solution proposed by u/tenthmascot at
      # https://www.reddit.com/r/adventofcode/comments/1pk87hl/2025_day_10_part_2_bifurcate_your_way_to_victory/
      solve(j) : memoize => keep "$s/$j" _->
        if j âˆ€ =0 then 0                                    # all 0, nothing more to do
        else
          l := j.indexed.map ||>i,jo->jo%2<<i .fold1 (|)    # desired lights = odd joltages
          (0..(2**buttons.length-1)).map m->                # for all button combinations
              pr := buttons.zip (m :: (/2)) b,mb->mb%2*b    # pressed buttons
              if l = pr.fold1 (^) then                      # resulting lights ok?
                j2 := j.indexed.map ||>i,jo->(jo - (pr.map b->(b>>i)%2 .sum))/2
                m.ones_count + 2 * solve j2                 # recurse with halved joltage
              else 1000000
            .min.val
      solve joltage

  part1 =>
    input.map d->((0..).drop_while n->(!d.try 0 n))[0]
         .sum

  part2 =>
    input.map (.p2)
         .sum

  say "$part1:$part2"
