dec9 =>

  input := io.stdin.read_string.trim.split "\n"
             .map (.split "," .map (.parse_i64.val) .as_tuple) .as_array
  xs := input.map (.0) .unique .sort
  ys := input.map (.1) .unique .sort
  x(v) => xs.find_key v .val.as_i64
  y(v) => ys.find_key v .val.as_i64

  part1 =>
    input.foldf (i64 0) e,a->
      input.foldf e f,b->
        max f (a.0-b.0+1)*(a.1-b.1+1)

  part2 =>
    m : mutate is
    m ! ()->
      floor := m.env.new_array2 xs.length.as_i64 ys.length.as_i64 "."
      show =>
        floor.indices1.for_each y->
          floor.indices0.for_each x->(yak floor[x,y])
          say ""
        say ""
      input.for_each (a -> floor[x a.0, y a.1] := "#")
      (input ++ [input[0]]).map_pairs p,q->
                             px := x p.0; py := y p.1
                             qx := x q.0; qy := y q.1
                             for xi := px, xi+(qx-px).sign.as_i64
                                 yi := py, yi+(qy-py).sign.as_i64
                             while xi!=qx || yi!=qy do
                               if floor[xi,yi]="." then floor[xi,yi] := "X"
                           .for_each ignore
      floor.indices1.for_each y->
        clear(e,x) => if !e && floor[x,y]="." then floor[x,y] := " "; false else true
        _ := floor.indices0.foldf false (e,x -> clear e x)
        _ := floor.indices0.foldf false (e,x -> clear e (xs.length-1).as_i64-x)
      input.foldf (i64 0) e,a->
             input.foldf e f,b->
               m0 := ((|a.0-b.0|)+1)*((|a.1-b.1|)+1)
               xab := [x a.0, x b.0].sort.as_tuple ||> (..)
               yab := [y a.1, y b.1].sort.as_tuple ||> (..)
               if m0 > f && (xab.pairs yab
                                .map p->floor[p.0,p.1] âˆ€ !=" ") then m0
                                                                else f

  say "$part1:$part2"
