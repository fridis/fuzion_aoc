dec9 =>

  input := io.stdin.read_string.trim.split "\n"
             .map (.split "," .map (.parse_i64.val) .as_tuple) .as_array
  xs := input.map (.0) .unique .sort
  ys := input.map (.1) .unique .sort
  x(v) => xs.find_key v .val.as_i64
  y(v) => ys.find_key v .val.as_i64
  rect(ab) => ((|ab.0.0-ab.1.0|)+1)*((|ab.0.1-ab.1.1|)+1)

  part1 =>
    input.combine input tuple
         .map rect
         .max

  part2 =>
    m : mutate is
    m ! ()->
      floor := m.env.new_array2 xs.length.as_i64 ys.length.as_i64 "."
      input.for_each (a -> floor[x a.0, y a.1] := "#")
      (input ++ [input[0]]).map_pairs tuple
                           .for_each ||>p,q->
                             px := x p.0; py := y p.1
                             qx := x q.0; qy := y q.1
                             _ := for xi := px, xi+(qx-px).sign.as_i64
                                      yi := py, yi+(qy-py).sign.as_i64
                                  while xi!=qx || yi!=qy do
                                    if floor[xi,yi]="." then floor[xi,yi] := "X"
      floor.indices1.for_each y->
        clear(e,x) => if !e && floor[x,y]="." then floor[x,y] := " "; false else true
        _ := floor.indices0.foldf false (e,x -> clear e x)
        _ := floor.indices0.foldf false (e,x -> clear e (xs.length-1).as_i64-x)
      input.combine input tuple
           .foldf (i64 0) e,ab->
               xab := [x ab.0.0, x ab.1.0].sort.as_tuple ||> (..)
               yab := [y ab.0.1, y ab.1.1].sort.as_tuple ||> (..)
               if rect ab > e && (xab.pairs yab
                                     .map p->floor[p.0,p.1] âˆ€ !=" ") then rect ab
                                                                     else e

  say "$part1:$part2"
