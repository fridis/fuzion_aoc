dec9 =>

  input := io.stdin.read_string.trim.split "\n"
             .map (.split "," .map (.parse_i64.val) .as_tuple) .as_array

  # area or rectangle with corners a and b
  rect(a,b) => ((|a.0-b.0|)+1)*((|a.1-b.1|)+1)

  part1 =>
    input.combine input rect
         .max

  part2 =>
    xs := input.map (.0) .unique .sort   # all used x coordinates
    ys := input.map (.1) .unique .sort   # all used y coordinates
    x(v) => xs.find_key v .val.as_i64    # compress x to index in xs
    y(v) => ys.find_key v .val.as_i64    # compress y to index in ys

    m : mutate is
    m ! ()->
      floor := m.env.new_array2 xs.length.as_i64 ys.length.as_i64 "."

      # put outline tiles
      (input ++ [input[0]])
        .map_pairs p,q->
          px := x p.0; py := y p.1
          qx := x q.0; qy := y q.1
          for xi := px, xi+(qx-px).sign.as_i64
              yi := py, yi+(qy-py).sign.as_i64
          while xi!=qx || yi!=qy do
            if floor[xi,yi]="." then floor[xi,yi] := "X"
        .for_each ignore   # enforce side-effect

      # clear outside area
      floor.indices1.for_each y->
        clear(x) => if floor[x,y]="." then floor[x,y] := " "; true
                                      else false
        _ := floor.indices0        .take_while clear .count
        _ := floor.indices0.reverse.take_while clear .count

      # try all rectangles
      input.combine input a,b->
             xr := [x a.0, x b.0].sort.as_tuple ||> (..) # range of x coord.
             yr := [y a.1, y b.1].sort.as_tuple ||> (..) # range of y coord.
             if xr.combine yr floor[] âˆ€ !=" " then rect a b
                                              else 0
           .max

  say "$part1:$part2"
