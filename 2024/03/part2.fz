err(h unit->void) : eff.fallible unit h is
  public fixed redef type.new(h unit->void) => err h

err => err.env.cause unit

dec3_part2 =>

  LM : mutate is
  input := LM ! ()->((io.stdin LM) ! ()->(io.buffered.read_lines LM)).filter !=""

  data := input.reduce "" (+)
               .as_codepoints

  parser(d) is

    skip(str, dd) Sequence codepoint =>
      cps := str.as_codepoints
      if dd.starts_with cps
        dd.drop cps.count
      else
        err

    skip_num(dd) =>
      match dd.first
        nil         => err
        x codepoint => if x.val âˆ‰ codepoint.ascii_digit then err
      for
        v := u32 0, v*10 + cp.val - "0".val
        rst Sequence codepoint := dd, rst.drop 1
        cp in rst
      while cp.val âˆˆ codepoint.ascii_digit else
        (v, rst)

    (num, rest) :=
       err.try ()->
            n1 := skip "mul(" d |> skip_num
            n2 := skip "," n1.1 |> skip_num
            (n1.0*n2.0, skip ")" n2.1)
          .catch _->
            (u32 0, id (Sequence codepoint) (d.drop 1))

    is_str(s) => err.try ()->
                    _ := skip s d
                    true
                  .catch _->
                    false
    is_do   := is_str "do()"
    is_dont := is_str "don't"

  part1 =>
    for
      s := u32 0, s + p.num
      d := data, p.rest
      p := parser d
    while !d.is_empty
    else
      s

  part2 =>
    for
      enabled := true, enabled && !p.is_dont || p.is_do
      s := u32 0, s + (enabled ? p.num : 0)
      p := parser data, parser p.rest
    while !p.rest.is_empty
    else
      s

  say part1
  say part2

dec3_part2
