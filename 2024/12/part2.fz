dec12 =>

  input := io.stdin.read_lines.filter !="" .map (.as_codepoints)
  w := input[0].count
  h := input.count
  data := array2 w+2 h+2 x,y->(1<=x<=w && 1<=y<=h ? input[y-1][x-1] : "0")

  part1 =>
    lm : mutate is
    lm ! ()->
      tot := lm.env.new 0
      done := (mutate.array2 bool).new lm (w+2).as_i64 (h+2).as_i64 false
      for xx in 1..w do
        for yy in 1..h do
          kind := data[xx,yy]
          (a,l) := fill xx yy
          fill(x,y) =>
            if kind != data[x,y]
              (0, 1)
            else if done[x.as_i64,y.as_i64]
              (0, 0)
            else
              done[x.as_i64,y.as_i64] := true
              (a1,l1) := if kind = data[x,y] then fill x+1 y   else (0,1)
              (a2,l2) := if kind = data[x,y] then fill x   y+1 else (0,1)
              (a3,l3) := if kind = data[x,y] then fill x-1 y   else (0,1)
              (a4,l4) := if kind = data[x,y] then fill x   y-1 else (0,1)
              (1+a1+a2+a3+a4, l1+l2+l3+l4)
          tot <- a*l + tot
#          say "$xx $yy $kind $a * $l = $tot"
      tot.get

  part2 =>
    lm : mutate is
    lm ! ()->
      tot := lm.env.new 0
      done := (mutate.array2 bool).new lm (w+2).as_i64 (h+2).as_i64 false
      for xx in 1..w do
        for yy in 1..h do
          kind := data[xx,yy]
          (a,s) := fill xx yy
          fill(x,y) =>
            if kind != data[x,y]
              (0, 0)
            else if done[x.as_i64,y.as_i64]
              (0, 0)
            else
              done[x.as_i64,y.as_i64] := true
              (a1,s1) := if kind = data[x,y] then fill x+1 y   else (0,1)
              (a2,s2) := if kind = data[x,y] then fill x   y+1 else (0,1)
              (a3,s3) := if kind = data[x,y] then fill x-1 y   else (0,1)
              (a4,s4) := if kind = data[x,y] then fill x   y-1 else (0,1)
              (1+a1+a2+a3+a4, s1+s2+s3+s4+ sides x y)
          sides(x,y) =>
            # a horizontal side stars in these configurations:
            #
            # 1.A|X 2.A X 3.X X 4.* *  5.* * 6.* *
            #    +-    +-    +-
            #   A A   X|A   X|A   X|A   X|A    A A
            #                      +-    +-     +-
            #   * *   * *   * *   X X   A X    A|X
            #
            # no horizontal side starts in all of these configurations:
            #
            #   A A   X|A   X X   A A   X|A
            #         -+    ---   -+     |
            #   A A   A A   A A   X|A   X|A
            tl := data[x-1,y-1]; tl0 := tl = kind
            ts := data[x  ,y-1]; ts0 := ts = kind
            tr := data[x+1,y-1]; tr0 := tr = kind
            sl := data[x-1,y  ]; sl0 := sl = kind
            sr := data[x+1,y  ]; sr0 := sr = kind
            bl := data[x-1,y+1]; bl0 := bl = kind
            bs := data[x  ,y+1]; bs0 := bs = kind
            br := data[x+1,y+1];# br0 := br = kind
            ho1 := tl0 && sl0 && !ts0|| !ts0 && !sl0;
            ho2 := sl0 && bl0 && !bs0 || !sl0 && !bs0;
            ho := ho1 || ho2
            # a vertical side stars in the tranposed position, i.e, ts and sl / sl and br swapped:
            #
            # 1.A A 2.A|X 3.X X 4.* *  5.* * 6.* *
            #   -+    -+-    +-
            #   X|A   X|A   X|A   X|A   X|A    A A
            #                      +-    +-     +-
            #   * *   * *   * *   X X   A X    A|X
            # 1.A A 2.A X 3.X X
            #   -+     +-    +-
            #   X|A   X|A   X|A
            #
            ve1 := tl0 && ts0 && !sl0 || !ts0 && !sl0;
            ve2 := ts0 && tr0 && !sr0 || !ts0 && !sr0;
            ve := ve1 || ve2
            if false && kind = "A"
              hs1 := ho1 ? "-" : " "
              hs2 := ho2 ? "-" : " "
              vs1 := ve1 ? "|" : " "
              vs2 := ve2 ? "|" : " "
              say "$x $y $kind $ho $ve"
              say "$tl $ts $tr"
              say "  $hs1"
              say "$sl$vs1$kind$vs2$sr"
              say "  $hs2"
              say "$bl $bs $br"
            ignore sr+bs
            (ho1 ? 1 : 0) + (ve1 ? 1 : 0) + (ho2 ? 1 : 0) + (ve2 ? 1 : 0)

          tot <- a*s + tot
          if (a*s != 0) say "$xx $yy $kind $a * $s = {a*s} tot: $tot"
      tot.get

  say "$part1,$part2"
