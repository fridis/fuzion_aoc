dec16 =>

  input := io.stdin.read_string
             .split "\n" .as_array
             .filter !=""
             .map (.as_codepoints)
  h := input.count
  w := input[0].count
  area := array2 codepoint h w y,x->input[y][x]
  point(y,x) is
    redef as_string => "$x $y"
    yy => y.as_i64
    xx => x.as_i64
  #  say "$area"
  e := area.index_pairs.filter (yx -> yx ||> y,x->area[y,x]="E") .first.or_else (panic "E not found") ||> point
  s := area.index_pairs.filter (yx -> yx ||> y,x->area[y,x]="S") .first.or_else (panic "S not found") ||> point

  lm : mutate is

  lm ! ()->

#      say "starting..."
    steps := lm.env.new 0
    costs := array2 4 h s,y->
      (mutate.array i32).type.new lm w.as_i64 i32.max

#      (0..3).for_each (d -> a := costs[d,e.y]; a[e.x.as_i64] := 0 )

    (0..3).for_each (d -> trace d e 0)

    cur_cost(d,p) => costs[d,p.y][p.x.as_i64];
    set_cost(d,p,cost) => costs[d,p.y][p.x.as_i64] := cost

    move(d,p,cost) =>
      p2 := if      d = 0 then point p.y+1 p.x   // up backwardds, i.e., down
            else if d = 1 then point p.y   p.x+1 // left backwards, i.e., right
            else if d = 2 then point p.y-1 p.x   // down backwards, i.e., up
            else               point p.y   p.x-1 // right backwards, i.e. left
      if (".S".contains area[p2.y,p2.x] &&
          cost+1 < cur_cost d p2 &&
          cost+1 < cur_cost 3 s)
      then
        trace d p2 cost+1

    trace(d, p, cost) =>
      if cost < cur_cost d p then
        set_cost d p cost
        if false then
          st := steps.get + 1
          steps <- st
          if (st & (st-1))=0 then show
        # try moving
        move d p cost
        # try turning
        trace (d+1)%4 p cost+1000
        trace (d+2)%4 p cost+2000
        trace (d+3)%4 p cost+1000

    show =>
     for y in 0..(h-1) do
      for x in 0..(w-1) do
        p := point y x
        c := min (min (min (cur_cost 0 p) (cur_cost 1 p)) (cur_cost 2 p)) (cur_cost 3 p)
        if c < i32.max then
          yak (((c > 10000000) ? "XX" : ((c > 99999) ? ("*"+(c/1000)+"*") : $c).pad_center 6))
        else
          yak area[y,x]*6
      else
        say ""

    part1 => cur_cost 3 s

    part2 =>
      best_paths := (mutate.array2 bool).type.new lm h.as_i64 w.as_i64 false
      num_best_paths := lm.env.new 0
      turns(d1,d2) =>
        if      (d1 = d2)       then 0
        else if (d1 = (d2+1)%4) then 1
        else if (d1 = (d2+2)%4) then 2
        else                         1
      mark_best_paths(d, p) =>
        if !best_paths[p.yy,p.xx] then
          num_best_paths <- num_best_paths.get + 1
          best_paths[p.yy, p.xx] := true
          if cur_cost 0 p != 0
            min_cost(pp) =>
              r := (0..3).map (dd -> cur_cost dd pp) .reduce i32.max min
              r
            pu := point p.y-1 p.x  ; cu := min_cost pu +^ 1000 * (turns 0 d)
            pd := point p.y+1 p.x  ; cd := min_cost pd +^ 1000 * (turns 2 d)
            pl := point p.y   p.x-1; cl := min_cost pl +^ 1000 * (turns 1 d)
            pr := point p.y   p.x+1; cr := min_cost pr +^ 1000 * (turns 3 d)
            cmin := [cu,cd,cl,cr].reduce i32.max min
            if cu = cmin then mark_best_paths 0 pu
            if cd = cmin then mark_best_paths 2 pd
            if cl = cmin then mark_best_paths 1 pl
            if cr = cmin then mark_best_paths 3 pr
      mark_best_paths 3 s

      if false
        for y in 0..(h-1) do
         for x in 0..(w-1) do
          p := point y x
          if best_paths[y.as_i64,x.as_i64] then
            yak "O"
          else
            yak area[y,x]
         else
          say ""
      num_best_paths.get

    say "$part1,$part2"
