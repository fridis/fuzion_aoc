dec16 =>

  input := io.stdin.read_string
             .split "\n" .as_array .filter !=""
             .map (.as_codepoints) .as_array
  h := input.count
  w := input[0].count
  area := array2 codepoint h w y,x->input[y][x]
  point(y,x) is
    yy => y.as_i64
    xx => x.as_i64
  e := area.index_pairs.filter (||> y,x->area[y,x]="E") .first.val ||> point
  s := area.index_pairs.filter (||> y,x->area[y,x]="S") .first.val ||> point

  lm : mutate is
  lm ! ()->
    costs := array2 4 h s,y->
      (mutate.array i32).type.new lm w.as_i64 i32.max

    (0..3).for_each (d -> trace d e 0)

    cur_cost(d,p) => costs[d,p.y][p.x.as_i64];
    set_cost(d,p,cost) => costs[d,p.y][p.x.as_i64] := cost

    dirs(d) =>
      if      d=0 then [-1,  0]
      else if d=1 then [ 0, -1]
      else if d=2 then [+1,  0]
      else             [ 0, +1] # up, left, down, right

    move(d,p,cost) =>
      p2 := point p.y-(dirs d)[0] p.x-(dirs d)[1]
      if (".S".contains area[p2.y,p2.x] &&
          cost+1 < cur_cost d p2 &&
          cost+1 < cur_cost 3 s) then
        trace d p2 cost+1

    trace(d, p, cost) =>
      if cost < cur_cost d p then
        set_cost d p cost
        # try to move
        move d p cost
        # try to turn
        trace (d+1)%4 p cost+1000
        trace (d+2)%4 p cost+2000
        trace (d+3)%4 p cost+1000

    part1 => cur_cost 3 s

    part2 =>
      best_paths := (mutate.array2 bool).type.new lm h.as_i64 w.as_i64 false
      turns(d1,d2) =>
        if      (d1 = d2)       then 0
        else if (d1 = (d2+2)%4) then 2
        else                         1
      mark_best_paths(d, p) =>
        if !best_paths[p.yy,p.xx] then
          best_paths[p.yy, p.xx] := true
          if cur_cost 0 p != 0
            pd(dd)     => point p.y+(dirs dd)[0] p.x+(dirs dd)[1]
            min_cst(dd) =>
              cur_cost dd (pd dd) +^ 1000 * (turns dd d)
            cmin := (0..3).map min_cst .reduce i32.max min
            (0..3).for_each (dd -> if min_cst dd = cmin then mark_best_paths dd (pd dd))
      mark_best_paths 3 s
      best_paths.as_array.filter id .count

    say "$part1,$part2"
