dec8_part2 =>

  LM : mutate is
  LM ! ()->
    data := (io.stdin LM) ! ()->(io.buffered.read_lines LM)
             .filter !="" .first.val.as_codepoints.map (.parse_i64.val) .as_array
    disk := data.zip ((i64 0 ..).flat_map (n -> id (Sequence i64) [n,-1])) a,b->(a,b)
                .flat_map (||> n,id -> id (Sequence i64) ([id].cycle.take n.as_i32))
                .as_array

    part1 =>
      rev Sequence i64 := disk.filter >=0 .reverse .as_array
      c0 := rev.count
      compacted := disk.reduce (id (Sequence i64) [], rev, 0) (
              rrv,id0 -> rrv |||> res,rv,n ->
                           (h,rr) := if      c0 <= n     then (i64 -1, rv                           )
                                     else if id0 >= 0    then (id0   , rv                           )
                                     else if rv.is_empty then (i64 -1, rv                           )
                                     else                     (rv[0] , id (Sequence i64) (rv.drop 1))
                           (id (Sequence i64) [h]++res, rr, n+1))

      ca := compacted.0.reverse
      ca.zip (i64 0).. a,b->(a,b) .map (||> id,n -> (max 0 id)*n) |> sum

    part2 =>
      sz := disk.count
      rev Sequence i64 := disk.reverse.as_array
      mdisk := (mutate.array i64).type.new LM sz.as_i64 0
      for i in disk.indices
          j in mdisk.indices
      do
        mdisk[j] := disk[i]
      free := (mutate.array i32).type.new LM sz.as_i64 0

      for p := i64 -1, disk[i]
          f := 0, nf
          i in (sz-1)..0:(-1)
          i2 := i.as_i64
          nf := disk[i] = p ? f+1 : 1
      do
        free[i2] := nf

      for
        l := 0, nl
        p := i64 -1, x
        x in rev
        xi in 0..
        i := rev.count-xi
        nl := p = x ? l+1 : 1
      do
        if p != x && p != -1
//          say "$p len $l "+(mdisk.as_array.reduce "" r,n->(n<0?"$r.":"$r$n"))+" "+free
          for ii := 0, ii+fl
              ii2 := ii.as_i64
          while ii < i
            fl := free[ii2]
            done1 := mdisk[ii2]<0 && fl>=l
            if done1
              for j in 0..(l-1) do
                mdisk[(ii+j).as_i64] := p
                mdisk[(i+j).as_i64] := -1
                free[(ii+j).as_i64] := l-j
              #free[ii2] := fl-l
          until done1
            unit
          else
            unit

//      say (mdisk.as_array.reduce "" r,n->(n<0?"$r.":"$r$n"))
//      say "free: $free \n rev: $rev \n $disk"
      mdisk.as_array.zip (i64 0).. a,b->(a,b) .map (||> id,n -> (max 0 id)*n) |> sum
    say "$part1,$part2"
