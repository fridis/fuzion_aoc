dec24

cycle_err(h unit->void) : eff.fallible unit h is
  public fixed redef type.new(h unit->void) => cycle_err h

dec24 =>

  dbg := mut false

  input := io.stdin.read_string.split "\n\n"
  in_wires := input[0].split "\n" .filter !=""
  in_gates := input[1].split "\n" .filter !=""

  Wire(name String) ref is
    state(get String->bool) bool => abstract
    state(x,y i64, get (i64,i64,String)->option bool) option bool => abstract
    ok := mut 0
    mark_ok(get String->Wire) =>
      ok <- 1+ok
    unmark_ok(get String->Wire) =>
      ok <- -1+ok
    get_unmarked(get String->Wire) Sequence Wire => []

  input_wire(redef name String, state0 bool) : Wire name is
    ok <- 1
    redef as_string => "$name: $state0"
    redef state(get String->bool) bool => state0
    redef state(x,y i64, get (i64,i64,String)->option bool) option bool =>
      b := name.substring 1 .parse_i64.val
      v := name.starts_with "x" ? true_  => x
                                | false_ => (name.starts_with "y" ? true_  => y
                                                                  | false_ => panic "x y expected $name")
      ((v >> b) & 1) != 0

  input_gate(in1 String, op String, in2 String, redef name String) : Wire name is
    cycle := mut false
    redef as_string => "$in1 $op $in2 -> $name"
    redef state(get String->bool) bool =>
      a := get in1
      b := get in2
      if op = "AND" then a && b
      else if op = "OR" then a || b
      else if op = "XOR" then a ^ b
      else panic "unkown $op"
    redef state(x,y i64, get (i64,i64,String)->option bool) option bool =>
      if cycle.get then
        nil
#        cycle_err.env.cause unit
      else
        cycle <- true
        a := get x y in1
        b := get x y in2
        res := a >>= aa->
                 b >>= bb->
                   if      op = "AND" then aa && bb
                   else if op = "OR"  then aa || bb
                   else if op = "XOR" then aa ^  bb
                   else panic "unkown $op"
        cycle <- false
        res
    redef mark_ok(get String->Wire) =>
      ok <- 1+ok
      (get in1).mark_ok get
      (get in2).mark_ok get
    redef unmark_ok(get String->Wire) =>
      ok <- -1+ok
      (get in1).mark_ok get
      (get in2).mark_ok get
    redef get_unmarked(get String->Wire) Sequence Wire =>
      r1 := (get in1).get_unmarked get
      r2 := (get in2).get_unmarked get
      r := r1 ++ r2
      if ok.get > 0 then r++[]
      else               r++[input_gate.this]

  part1 =>
    iws := in_wires.map (s -> s.split ": " |> (iw -> input_wire iw[0] iw[1]="1"))
    igs := in_gates.map (s -> s.split " "  |> (ig -> input_gate ig[0] ig[1] ig[2] ig[4]))
    bits := igs.map (.name) .filter (.starts_with "z") .map (.replace "z" "" .parse_i32.val) .fold1 max
    wires := iws.map (w -> id Wire w) ++ igs.map (w -> id Wire w)
    names := wires.map (.name)
    all_wires := (container.ps_map String Wire).new names wires

    get_state(name) => all_wires[name].val.state get_state

    for r := i64 0, r | ((get_state "z"+(i.as_string 2 10) ? i64 1 : 0) << i.as_i64)
        i in 0..bits
    else
      r

  part2 =>
    iws := in_wires.map (s -> s.split ": " |> (iw -> input_wire iw[0] iw[1]="1"))
    igs := in_gates.map (s -> s.split " "  |> (ig -> input_gate ig[0] ig[1] ig[2] ig[4]))
    bits := igs.map (.name) .filter (.starts_with "z") .map (.replace "z" "" .parse_i32.val) .fold1 max
    wires := iws.map (w -> id Wire w) ++ igs.map (w -> id Wire w)
    names := wires.map (.name)
    all_wires := (container.ps_map String Wire).new names wires

    get_state(repl,x,y,name) =>
#      yak repl.count
      for n := name, nn
          t in repl
          nn := if      t.0 = n then  t.1
                else if t.1 = n then t.0
                else n
      do # yak "[$name>$nn,{t.0}/{t.1}]"
      else
#        if name != n then yak "-$name-*$n*"
        res := all_wires[n].val.state x y (get_state repl)
        if dbg.get then say "get_state $name -> $n is $res"
#        if name="z00" then
#          say "##### z00 is "+res+" $name -> $n"
        res
    get_wire(name) => all_wires[name].val

/*
    get_z(repl Sequence (String,String), x,y) option i64 =>
      for r := i64 0, r | ((s .val ? i64 1 : 0) << i.as_i64)
          i in 0..bits
          s := get_state repl x y "z"+(i.as_string 2 10)
      until s!!
        id (option i64) nil
      else
        r
*/
    get_zb(b i32, repl Sequence (String,String), x,y) =>
      get_state repl x y "z"+(b.as_string 2 10)

/*
    get_z0(repl Sequence (String,String), x,y) option i64 =>
      for r := i64 0, r | ((s .val ? i64 1 : 0) << i.as_i64)
          i in 0..2
          s := get_state repl x y "z"+(i.as_string 2 10)
          _ := say "bit $i of result is $s"
      until s!!
        id (option i64) nil
      else
        r
*/
    check_bit(repl Sequence (String, String), b i32) =>
      bl := b.as_i64
      base_cases := [(i64 0 << bl, i64 0 << bl),   # hhh0lll + hhh0lll
                     (i64 1 << bl, i64 0 << bl),   # hhh1lll + hhh0lll
                     (i64 0 << bl, i64 1 << bl),   # hhh0lll + hhh1lll
                     (i64 1 << bl, i64 1 << bl)]   # hhh1lll + hhh1lll
#      say "bases $b $base_cases"
      lo := (i64 1 << (bl))-1                      # 0000111
      hi := (i64 1 << bits.as_i64) - (i64 1 << bl) # 1110000
      carry_cases := base_cases.map (||> x,y -> (x+lo,y+lo))
      leading1_casesa := base_cases.map (||> x,y -> (x+hi,y))
      leading1_casesb := base_cases.map (||> x,y -> (x,y+hi))
      leading1_cases := leading1_casesa ++ leading1_casesb
      /*
      leading1_cases := (base_cases.map (||> x,y -> (x+hi,y)) ++
                         base_cases.map (||> x,y -> (x,y+hi)))
                         */
      for c in (base_cases ++ carry_cases ++ leading1_cases)
          ro := get_zb b repl c.0 c.1
      do
#        say "check bit $b: {c.0.as_string 2} + {c.1.as_string 2} = {r.bin} not {(c.0+c.1).bin}"
      until match ro
              r bool => r != ((c.0 + c.1 & ((i64 1 << bl))) != 0)
              nil => true
                    then
        #dbg <- true
        #_ := get_z0 repl c.0 c.1
        #dbg <- false
        # say "problem for bit $b: {c.0.as_string 2} + {c.1.as_string 2} = {ro} not {(c.0+c.1).bin}"
        false
      else
        true

    find_repl(b0, b i32, repl Sequence (String,String)) option (Sequence (String,String)) =>
#      for b in 0..bits-1 do
#          say "------ bit $b -------"
#        nrepl :=
          if b >= bits then
            repl
          else if check_bit repl b then
            all_wires["z"+(b.as_string 2 10)].val.mark_ok get_wire
            if b > b0 then    say "------ bit $b -------"
            res := find_repl (max b0 b) b+1 repl
            all_wires["z"+(b.as_string 2 10)].val.unmark_ok get_wire
            res
          else if /* b0 >= b || */ repl.count = 4
            nil
          else
            candidates := all_wires["z"+(b.as_string 2 10)].val.get_unmarked get_wire
            say "failed at $b CANDIDATES: "+candidates
            for cd in candidates do
                r0:= for w in all_wires.values
                         rr := repl++[(cd.name, w.name)]
                         r := if check_bit rr b then
                                say "trying {cd.name} -> {w.name}"
                                cycle_err.try ()->
                                           find_repl b0+1 b+1 rr
                                         .catch _->
                                           nil
                              else
                                nil
                     until r?? then
                       r
                     else
                       nil
            until r0??  then r0 else nil
#              if !w.ok.get then
#              say "try replace "+candidates.first.val+" with "+w+"!"
#                if check_bit [(candidates.first.val.name, w.name)] b then say "** SUCCESS "+candidates.first.val+" with "+w+"! ***"
#            repl
    rs := cycle_err.try ()->
                    find_repl -1 0 []
                  .catch e->
                    panic "cycle err!"
    rs.map (.flat_map (t -> id (Sequence String) [t.0,t.1]) .sort .as_string ",")

  say "$part1:$part2"
