dec19 =>

  input := io.stdin.read_lines
  input1 := input[0].split ", " .as_array
  input2 := input.drop 2 .filter !=""

  sorted := input1.sort_by a,b->a.byte_length>=b.byte_length
  String.suffix(prfx) => substring prfx.byte_length

  M : mutate is
  M ! ()->
    cachePos := (container.mutable_tree_map M String bool).empty
    cacheCnt := (container.mutable_tree_map M String i64 ).empty

    possible(s) =>
      match cachePos.get s
        v bool => v
        nil    => res := s="" || !sorted.filter p->
                                           (s.starts_with p &&
                                            possible (s.suffix p))
                                        .is_empty
                  cachePos.put s res
                  res

    count(s) =>
      match cacheCnt.get s
        v i64 => v
        nil   => res := if      s=""        then 1
                        else if !possible s then 0
                        else
                          sorted.filter s.starts_with
                                .map p->count(s.suffix p) |> sum
                 cacheCnt.put s res
                 res

    part1 => input2.filter possible .count
    part2 => input2.map count |> sum

    say "$part1:$part2"
