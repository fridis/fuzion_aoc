dec20 =>

  minsaving := envir.args[1].parse_i32.val
  input := io.stdin.read_lines.filter !="" .map (.as_codepoints)
  w := input[0].count
  h := input.count
  area := array2 w h x,y->input[y][x]

  point(x,y) : property.equatable is
    xl => x.as_i64
    yl => y.as_i64
    redef type.equality(a,b point.this) => a.x=b.x && a.y=b.y
    neighbors   => [up, dw, le, ri].filter (.valid)
    valid       => 0 <= x < w && 0 <= y < h
    on_track    => area[x,y] != "#"
    inner_wall  => 1 <= x < w-1 && 1 <= y < h-1 && area[x,y] = "#"
    abs         => (|x|) + (|y|)
    infix + (o) => point x+o.x y+o.y
    infix - (o) => point x-o.x y-o.y
    up => { point x y-1}; dw => { point x y+1 }
    le => { point x-1 y}; ri => { point x+1 y }

  s := area.index_pairs.filter (||> y,x->area[y,x]="S") .first.val ||> point

  M : mutate is
  M ! ()->
    track := (mutate.array point).type.new M
    picos := (mutate.array2 i32).type.new M w.as_i64 h.as_i64 -1
    picos(p) => picos[p.xl,p.yl]
    for p := s, p.neighbors.filter (.on_track)
                           .filter q->picos[q.xl,q.yl]<0
                           .first.val
        ps := 0, ps+1
    do
      picos[p.xl,p.yl] := ps
      track.add p
    until area[p.x,p.y] = "E"
      unit

    part1 =>
      saving(p) =>
        t := picos p.up; b := picos p.dw
        l := picos p.le; r := picos p.ri
        if      t>=0 && b>=0 then (|t-b|)-2
        else if l>=0 && r>=0 then (|l-r|)-2
        else                      0
      area.index_pairs.map ||>point
          .filter (.inner_wall)
          .map saving
          .filter >=minsaving
          .count

    part2 =>
      range := -20 .. 20
      track.as_array.flat_map pi->
          range.combine range point
               .filter (p -> p.abs <= 20)
               .map    (pi+)
               .filter (.valid)
               .filter (.on_track)
               .map (pj -> picos pj - picos pi - (pj-pi).abs)
               .filter >=minsaving
        .count

    say "$part1:$part2"
