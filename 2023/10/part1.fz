dec10_part1 is

  LM : mutate is
  cp := LM ! ()->io.stdin.reader LM ! ()->io.buffered LM
    .read_lines
    .filter !=""
    .map s->s.codepoints

  # our map
  map := array2 cp.count cp[0].count i,j->cp[i][j]

  at(i,j) => if map.indices0.contains i && map.indices1.contains j then map[i,j] else "."

  # a direction
  dir(di, dj i32,   # delta to move one step in this direction
      next String)  # possible next tiles
  is
    # get next direction using given tile, nil if that tile is not connected
    next(i,j i32) => (next.find (at i j)).map ix->dirs[ix] .as_list

    # move one step from i,j and check if that tile connects to i,j
    connects(i,j) => !(next i+di j+dj).is_empty

  # all four directions
  dirs array dir := [ dir -1  0 "|#F7",   # north
                      dir +1  0 "#|LJ",   # south
                      dir  0 +1 "J7-#",   # east
                      dir  0 -1 "LF#-" ]  # west

  # find the start tile coordinates
  start =>
    for ij in map.index_pairs do
      i,j := ij
    until map[i,j] = "S"
      ij
    else
      panic "no start found"

  # find the loop:
  loup =>
    lm : mutate is
    lm.instate_self (array2 String) ()->
      lp := array map.length0 i->((lm.array String).type.new lm map.length1.as_i64 ".")

      i,j := start
      for d in dirs
      do
        if d.connects i j
          go d i j

      # recursively go along the pipe
      go(d dir, i0, j0 i32) =>
        ii := i0 + d.di
        jj := j0 + d.dj
        lp[ii][jj.as_i64] := at ii jj                # record path
        match d.next ii jj
          d1 Cons dir (list dir)=> go d1.head ii jj
          nil   =>

      # collect the resulting path as an array
      array2 map.length0 map.length1 i1,j1->lp[i1][j1.as_i64]

  part1 =>
    loup.filter !="."     # count the tiles in the loop and divide by 2
        .count / 2

  say "part1 $part1"
