dec3_part2 is

  codepoint.is_symbol => !is_ascii_digit && (codepoint val) != "."

  LM : mutate is
  lines := LM ! ()->
    io.stdin.reader LM ! ()->io.buffered LM .read_lines
     .filter !=""
     .as_array_backed

  scheme(ls Sequence String) is
    cp := ls.map (.codepoints)
    a := array2 cp.count cp[0].count i,j->cp[i][j]
    w => a.length1
    h => a.length0
    at(l,c) =>
      if 0 <= l < h && 0 <= c < w then a[l,c] else "."

    number(l, c i32) is
      len := (0.. .filter (x -> !(at l c+x).is_ascii_digit)).first.val
      ok bool := (-1..1) ∃ y -> (-1..len) ∃ x -> (at l+y c+x) .is_symbol
      val i32 := ls[l].substring c c+len
                      .parse_i32.val
      adj (i,j i32) => (l-1 <= i <= l+1   &&
                        c-1 <= j <= c+len   )

    numbers =>
      a.index_pairs.flat_map number ij->
        i,j := ij
        (!(at i j-1).is_ascii_digit &&
          (at i j  ).is_ascii_digit   ).as_option number (number i j)

    parts =>
      numbers.map (x -> if x.ok then x.val else 0)
             .fold i32.type.sum

    gears i32 =>
      a.index_pairs
       .map ij->
         i,j := ij
         if at i j = "*"
           k := numbers.filter (x -> x.adj i j)
           if k.count = 2 then k.first.val.val * k.last.val.val else 0
         else
           0
       .fold i32.type.sum

  s := scheme lines
  p := s.parts
  g := s.gears
  say "$p $g"
