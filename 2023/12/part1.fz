dec12_part1 is

  input := (io.stdin.with ()->io.buffered.read_lines).val.filter !=""

  record(s String) is
    springs := s.split[0]
                .as_codepoints
    groups  := s.split[1]
                .split ","
                .map_sequence (.parse_i32.val)
    redef as_string => "$springs $groups"

    count_arrangements(s, g, sr) i32 =>
#      say " "*s+"for {record.this} count $s $g $sr}"
      r := if sr > 0
        if s >= springs.count || springs[s] = "."
          0
        else if springs[s] = "#" || springs[s] = "?"
          count_arrangements s+1 g sr-1
        else
          panic "1"
      else if sr = 0
        if s >= springs.count || springs[s] = "."
          count_arrangements s g -1
        else if springs[s] = "#"
          0
        else if springs[s] = "?"
          count_arrangements s+1 g -1
        else
          panic "2"
      else
        if s >= springs.count && g >= groups.count
          1
        else if s >= springs.count
          0
        else if g >= groups.count && springs[s] = "."
          count_arrangements s+1 g sr
        else if g >= groups.count && springs[s] = "#"
          0
        else if g >= groups.count && springs[s] = "?"
          count_arrangements s+1 g sr
        else if springs[s] = "."
          count_arrangements s+1 g sr
        else if springs[s] = "#"
          count_arrangements s+1 g+1 groups[g]-1
        else if springs[s] = "?"
          c1 := count_arrangements s+1 g+1 groups[g]-1
          c2 := count_arrangements s+1 g sr
          c1+c2
        else
          panic "3"
#      say " "*s+"for {record.this} count $s $g $sr} => $r"
      r


  data := input.map_sequence record

  part1 =>
    data.map_sequence (.count_arrangements 0 0 -1) |> sum

  say "part1 $part1"
