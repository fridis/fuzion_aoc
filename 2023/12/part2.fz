dec12_part2 is

  input := (io.stdin.with ()->io.buffered.read_lines).val.as_array.filter !=""
                                                     .as_array

  binomial(n, k i64) =>
    for res := i64 1, res * (n+1-i) / i
        i in i64 1 .. k
    else
      res

  record(s String) =>
    (record (s.split[0]
             .as_codepoints)
            (s.split[1]
              .split ","
              .map_sequence (.parse_i32.val)))

  max := mut u64 0

  record(springs Sequence codepoint, groups Sequence i32) is
    redef as_string => "{springs.as_string ""} $groups"

    times5 => (record ((springs ++ ["?".as_codepoints.first]).cycle.take springs.count*5+4).as_array
                      (groups.cycle.take groups.count*5).as_array)


    count_arrangementsOLD(s, g, sr) i32 =>
#      say " "*s+"for {record.this} count $s $g $sr}"
      r := if sr > 0
        if s >= springs.count || springs[s] = "."
          0
        else if springs[s] = "#" || springs[s] = "?"
          count_arrangementsOLD s+1 g sr-1
        else
          panic "1"
      else if sr = 0
        if s >= springs.count || springs[s] = "."
          count_arrangementsOLD s g -1
        else if springs[s] = "#"
          0
        else if springs[s] = "?"
          count_arrangementsOLD s+1 g -1
        else
          panic "2"
      else
        if s >= springs.count && g >= groups.count
          1
        else if s >= springs.count
          0
        else if g >= groups.count && springs[s] = "."
          count_arrangementsOLD s+1 g sr
        else if g >= groups.count && springs[s] = "#"
          0
        else if g >= groups.count && springs[s] = "?"
          count_arrangementsOLD s+1 g sr
        else if springs[s] = "."
          count_arrangementsOLD s+1 g sr
        else if springs[s] = "#"
          count_arrangementsOLD s+1 g+1 groups[g]-1
        else if springs[s] = "?"
          c1 := count_arrangementsOLD s+1 g+1 groups[g]-1
          c2 := count_arrangementsOLD s+1 g sr
          c1+c2
        else
          panic "3"
#      say " "*s+"for {record.this} count $s $g $sr} => $r"
      r

    num_gq := (springs.filter c->(c="#" || c="?")).count
    num_g  := (springs.filter c->(c="#"         )).count
    remt       := ((groups .reduce (list i32, i32) ((list i32).type.empty,sum groups + groups.count - 1) a,g->{og := a.values.1; dg := og+g+1;(a.values.0 ++ [og], dg)}))
    rem        := (remt.values.0 ++ [0]).as_array
    say "{record.this} -> $rem"
    str_rem_gqt:= ((springs.reduce (list i32, i32) ((list i32).type.empty,num_gq) a,c->{dg := a.values.1 - {if c="#" || c="?" 1 else 0}; (a.values.0 ++ [dg], dg)}))
    str_rem_gq := (str_rem_gqt.values.0 ++ [0]).as_array
    str_rem_gt := ((springs.reduce (list i32, i32) ((list i32).type.empty,num_g ) a,c->{dg := a.values.1 - {if c="#"          1 else 0}; (a.values.0 ++ [dg], dg)}))
    str_rem_g  := (str_rem_gt.values.0  ++ [0]).as_array


    count_arrangements(s, g, sr) i64 =>
#     if s < springs.count && (rem[g] < str_rem_g[s] || rem[g] > str_rem_gq[s])
#      say "giving up {rem[g]} < {str_rem_g[s]} || {rem[g]} > {str_rem_gq[s]} for {record.this} count $s $g $sr}"
#      0
#     else
      n := max.get
      max <- n + 1
      if s < 25 if n < 100 || (n & (n-1))=0
#      say "$n:\t{" "*s} for {record.this} count $s $g $sr max {springs.count} {groups.count}"
      r := if sr > 0      if       s >= springs.count || springs[s] = "."     then  i64 0
                                                                    else count_arrangements s+1 g sr-1
      else if sr = 0 if s >= springs.count || springs[s] = "." then count_arrangements s g -1
                     else if springs[s] = "#" then         i64 0
                     else                         count_arrangements s+1 g -1
      else
        if      s >= springs.count && g >= groups.count then i64 1
        else if s >= springs.count                      then i64 0
        else if g >= groups.count && springs[s] = "."   then count_arrangements s+1 g sr
        else if g >= groups.count && springs[s] = "#"   then i64 0
        else if g >= groups.count && springs[s] = "?"   then count_arrangements s+1 g sr
        else if                      springs[s] = "."   then count_arrangements s+1 g sr
        else if                      springs[s] = "#"   then count_arrangements s+1 g+1 groups[g]-1
        else
          for q := 0, q+1 while s+q<springs.count && springs[s+q] = "?" else
            if s+q >= springs.count || springs[s+q] = "." then # we have q ? followed by .

              for ng := 0, ng + 1
                  csum := i64 0, csum + cng
              while g+ng <= groups.count && ((0..ng-1).map gi->groups[g+gi] |> sum) + ng - 1 <= q do
                # collapse groups to size 1 including gap:
                q_collapsed := q - ((0..ng-1).map gi->groups[g+gi] |> sum) + 1

                # we fit ng groups into q question marks
                factor := binomial q_collapsed.as_i64 ng.as_i64
#                say "$s ng:$ng f: $factor"

                cng := if factor = 0 then i64 0 else factor * count_arrangements s+q g+ng sr
#                say "$s ng:$ng f: $factor cng: $cng at {springs.drop s} {groups.drop g}"
              else
                csum
/*
              cold := if true then csum0 else for o := 0, o+1 while g+o < groups.count && groups[g+o] = 1 else
                if (o > 0) then
                  # we have q x ? . and we try to place o single #, so have
                  #
                  #  q  o  possibilities
                  #  n  1  n
                  #  1  2  0
                  #  2  2  0
                  #  3  2  1   #.#
                  #  4  2  2   #.#.   .#.#
                  #  5  2  3   #.#.. ..#.#. ##.#. .#.##  = 2*(p 4 2) + 2*(p 3 2)
                  p(q0,o0) =>
                    if      o0 = 0    then 1
                    else if 2*o0-1 > q0 then 0
                    else if o0 = 1    then q0
                    else                    p q0-1 o0 + p q0-2 o0-1
                  for co := i64 0, co + pp * cp
                      no := i64 0, no+1
                  while no <= o do
                    pp := p q no
                    cp := if pp = 0 then i64 0 else count_arrangements s+q+1 g+no -1
                  else
                    co
                else

                  if groups[g] > q then count_arrangements s+q+1 g sr
                  else
                    # we have ??????. and ###, so possible arrangements are
                    # c4: ###.??., c3: .###.?., c2: ..###.., c1: ...###., c0: .......
                    c0 := count_arrangements s+q+1 g   -1
                    c1 := count_arrangements s+q+1 g+1 -1
                    c2 := if q > groups[g] then c1 else 0
                    c3ff := for c3 := 0, c3 + count_arrangements s+q-c+2 g+1 -1
                                c := 3, c+1
                            while c + groups[g] <= q+1 else
                              c3
                    c0+c1+c2+c3ff
              if (csum0 != cold) panic "$csum0 != cold $n:\t{" "*s} for {record.this} count $s $g $sr}"
              cold */
            else # we have q ? followed by #

              for ng := 0, ng + 1
                  csum := i64 0, csum + cng + cls
              while g+ng < groups.count && ((0..ng-1).map gi->groups[g+gi] |> sum) + ng <= q do
                # collapse groups to size 1 including gap:
                q_collapsed := q - ((0..ng-1).map gi->groups[g+gi] |> sum)

                # we fit ng groups into q question marks
                factor := binomial q_collapsed.as_i64 ng.as_i64
                cng := if factor = 0 then i64 0 else factor * count_arrangements s+q g+ng sr

                # now try to connect the following one
                cls i64 := if g+ng < groups.count
                  lsz := groups[g+ng]
                  for cl := i64 0, cl + cd
                      nl := 1, nl + 1
                  while nl < lsz && q_collapsed-nl >= ng
                    factor2 := binomial (q_collapsed-nl).as_i64 ng.as_i64
                    cd := if factor2 = 0 then i64 0 else ca := count_arrangements s+q g+ng+1 lsz-nl; factor2 * ca
                  else
                    cl
                else
                  0

              else
                csum

#      say "$n:\t{" "*s} for {record.this} count $s $g $sr max {springs.count} {groups.count} -> $r"
      r
#          c1 := count_arrangements s+1 g+1 groups[g]-1
#          c2 := count_arrangements s+1 g sr
#          c1+c2


  data := input.map_sequence record

  part1 =>
     if false then data.map_sequence (.count_arrangementsOLD 0 0 -1) |> (s -> say s)
     if false then data.map_sequence (.count_arrangements 0 0 -1) |> (s -> say s)
     data.map_sequence (.count_arrangements 0 0 -1) |> sum


  part2 =>
    data := data.map_sequence (.times5)
    data.map_sequence (.count_arrangements 0 0 -1) |> sum

  say "part1 $part1"
  say "part2 $part2"
